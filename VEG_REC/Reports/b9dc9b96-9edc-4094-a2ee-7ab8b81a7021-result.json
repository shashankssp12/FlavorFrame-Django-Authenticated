{"name": "testCreateRecipe", "status": "broken", "statusDetails": {"message": "django.core.exceptions.FieldError: Cannot resolve keyword 'name' into field. Choices are: Recipe_view_count, Rimage, Rname, description, id, user, user_id", "trace": "self = <VEG_REC.tests.testRecipe testMethod=testCreateRecipe>\n\n    def tearDown(self):\n        # Delete the created Recipe objects\n        # Recipe.objects.all().delete()\n>       Recipe.objects.filter(name__icontains=\"test\").delete()\n\ntests.py:82: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\venv\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\n..\\venv\\Lib\\site-packages\\django\\db\\models\\query.py:1476: in filter\n    return self._filter_or_exclude(False, args, kwargs)\n..\\venv\\Lib\\site-packages\\django\\db\\models\\query.py:1494: in _filter_or_exclude\n    clone._filter_or_exclude_inplace(negate, args, kwargs)\n..\\venv\\Lib\\site-packages\\django\\db\\models\\query.py:1501: in _filter_or_exclude_inplace\n    self._query.add_q(Q(*args, **kwargs))\n..\\venv\\Lib\\site-packages\\django\\db\\models\\sql\\query.py:1602: in add_q\n    clause, _ = self._add_q(q_object, self.used_aliases)\n..\\venv\\Lib\\site-packages\\django\\db\\models\\sql\\query.py:1634: in _add_q\n    child_clause, needed_inner = self.build_filter(\n..\\venv\\Lib\\site-packages\\django\\db\\models\\sql\\query.py:1484: in build_filter\n    lookups, parts, reffed_expression = self.solve_lookup_type(arg, summarize)\n..\\venv\\Lib\\site-packages\\django\\db\\models\\sql\\query.py:1296: in solve_lookup_type\n    _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <django.db.models.sql.query.Query object at 0x0000018C3E7B60D0>, names = ['name', 'icontains'], opts = <Options for Recipe>, allow_many = True, fail_on_missing = False\n\n    def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n        \"\"\"\n        Walk the list of names and turns them into PathInfo tuples. A single\n        name in 'names' can generate multiple PathInfos (m2m, for example).\n    \n        'names' is the path of names to travel, 'opts' is the model Options we\n        start the name resolving from, 'allow_many' is as for setup_joins().\n        If fail_on_missing is set to True, then a name that can't be resolved\n        will generate a FieldError.\n    \n        Return a list of PathInfo tuples. In addition return the final field\n        (the last used join field) and target (which is a field guaranteed to\n        contain the same value as the final field). Finally, return those names\n        that weren't found (which are likely transforms and the final lookup).\n        \"\"\"\n        path, names_with_path = [], []\n        for pos, name in enumerate(names):\n            cur_names_with_path = (name, [])\n            if name == \"pk\" and opts is not None:\n                name = opts.pk.name\n    \n            field = None\n            filtered_relation = None\n            try:\n                if opts is None:\n                    raise FieldDoesNotExist\n                field = opts.get_field(name)\n            except FieldDoesNotExist:\n                if name in self.annotation_select:\n                    field = self.annotation_select[name].output_field\n                elif name in self._filtered_relations and pos == 0:\n                    filtered_relation = self._filtered_relations[name]\n                    if LOOKUP_SEP in filtered_relation.relation_name:\n                        parts = filtered_relation.relation_name.split(LOOKUP_SEP)\n                        filtered_relation_path, field, _, _ = self.names_to_path(\n                            parts,\n                            opts,\n                            allow_many,\n                            fail_on_missing,\n                        )\n                        path.extend(filtered_relation_path[:-1])\n                    else:\n                        field = opts.get_field(filtered_relation.relation_name)\n            if field is not None:\n                # Fields that contain one-to-many relations with a generic\n                # model (like a GenericForeignKey) cannot generate reverse\n                # relations and therefore cannot be used for reverse querying.\n                if field.is_relation and not field.related_model:\n                    raise FieldError(\n                        \"Field %r does not generate an automatic reverse \"\n                        \"relation and therefore cannot be used for reverse \"\n                        \"querying. If it is a GenericForeignKey, consider \"\n                        \"adding a GenericRelation.\" % name\n                    )\n                try:\n                    model = field.model._meta.concrete_model\n                except AttributeError:\n                    # QuerySet.annotate() may introduce fields that aren't\n                    # attached to a model.\n                    model = None\n            else:\n                # We didn't find the current field, so move position back\n                # one step.\n                pos -= 1\n                if pos == -1 or fail_on_missing:\n                    available = sorted(\n                        [\n                            *get_field_names_from_opts(opts),\n                            *self.annotation_select,\n                            *self._filtered_relations,\n                        ]\n                    )\n>                   raise FieldError(\n                        \"Cannot resolve keyword '%s' into field. \"\n                        \"Choices are: %s\" % (name, \", \".join(available))\n                    )\nE                   django.core.exceptions.FieldError: Cannot resolve keyword 'name' into field. Choices are: Recipe_view_count, Rimage, Rname, description, id, user, user_id\n\n..\\venv\\Lib\\site-packages\\django\\db\\models\\sql\\query.py:1761: FieldError"}, "start": 1706426554059, "stop": 1706426576082, "uuid": "ec895d23-d989-4d0b-8fd6-f4e7e7043056", "historyId": "9703b05535b94063e97762b158772403", "testCaseId": "9703b05535b94063e97762b158772403", "fullName": "tests.testRecipe#testCreateRecipe", "labels": [{"name": "suite", "value": "tests"}, {"name": "subSuite", "value": "testRecipe"}, {"name": "host", "value": "LAPTOP-85C54M6J"}, {"name": "thread", "value": "23812-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "tests"}]}